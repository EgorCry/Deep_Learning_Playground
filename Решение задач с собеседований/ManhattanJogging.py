"""
Дороги Нью-Манхэттена устроены следующим образом. С юга на север через каждые сто
метров проходит авеню, с запада на восток каждые сто метров проходит улица. Авеню
и улицы нумеруются целыми числами. Меньшие номера соответствуют западным авеню и
южным улицам. Таким образом, можно построить прямоугольную систему координат так,
что точка (x, y) лежала на пересечении x-ой авеню и y-ой улицы. Легко заметить, что
для того, чтобы в Нью-Манхэттене дойти от точки (x1, y1) до точки (x2, y2) нужно
пройти |x2-x1| + |y2-y1| кварталов. Эта величина называется манхэттенским рассто-
янием между точками (x1, y1) и (x2, y2).
Миша живёт в Нью-Манхэттене и каждое утро делает пробежку по городу. Он выбегает
из своего дома, который находится в точке (0, 0) и бежит по случайному маршруту.
Каждую минуту Миша остаётся на том же перекрёстке, что и минуту назад, или пере-
мещается на один квартал в любом направлении. Чтобы не заблудиться Миша берёт с
собой навигатор, который каждые t минут говорит Мише, в какой точке он находится.
К сожалению, навигато показывает не точное положение Миши, он может показать лю-
бую из точек, манхэттенское расстояние от которых до Миши не превышает d.
Через t*n минут от начала пробежки, получив n-e сообщение от навигатора. Миша ре-
шил, что пора бежать домой. Для этого он хочет понять, в каких точках он может
находиться. Помогите Мише сделать это.
"""

def extend(rect, d):
    minPlus, maxPlus, minMinus, maxMinus = rect
    return [minPlus - d, maxPlus + d, minMinus - d, maxMinus + d]


def intersect(rect_1, rect_2):
    ans = [max(rect_1[0], rect_2[0]), min(rect_1[1], rect_2[1]),
           max(rect_1[2], rect_2[2]), min(rect_1[3], rect_2[3])]
    return ans


t, d, n = map(int, input().split())
posRect = (0, 0, 0, 0)
for _ in range(n):
    posRect = extend(posRect, t)
    navX, navY = map(int, input().split())
    navRect = extend((navX + navY, navX + navY, navX - navY, navX - navY), d)
    posRect = intersect(posRect, navRect)

points = []
for xPlusY in range(posRect[0], posRect[1] + 1):
    for xMinusY in range(posRect[2], posRect[3] + 1):
        if (xPlusY + xMinusY) % 2 == 0:
            x = (xPlusY + xMinusY) // 2
            y = xPlusY - x
            points.append((x, y))

print(len(points))
for point in points:
    print(point)
